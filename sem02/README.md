# Контест по теме "Ввод-вывод, типы данных"

### Ссылка на контест
https://official.contest.yandex.ru/contest/51801/problems/

### Общее

Несколько слов об конструкции:
```python
def main():
    ...


if __name__ == '__main__':
    main()
```
- `def main()` - объявление [функции](https://docs.python.org/3/tutorial/controlflow.html#defining-functions) `main`. Дальше идет блок с кодом, который эта функция выполняет при ее вызове;
- `main()` - вызов функции;
- `if __name__ == '__main__`:
  - `__name__` - аттрибут, в котором следующее значение:
    - когда скрипт запускается напрямую, `__name__` устанавливается в `'__main__'`;
    - когда [модуль](https://docs.python.org/3/tutorial/modules.html) импортируется, `__name__` устанавливается в имя этого модуля;
  - То есть, выражение `if __name__ == '__main__` выполнится только, тогда, когда мы напрямую начнем исполнять файл.
- Плюс этой конструкции:
  - при импорте данного файла, никакой код не запустится, из-за `if __name__ == '__main__`;
  - А функция нужна для того, что бы все объявленные переменные попали в локальную [область видимости](https://www.yuripetrov.ru/edu/python/ch_05_01.html#id27) функции `main`. У `if` нет своей локальной области видимости, в отличие от других языков, например `C++`.

### H

Я решил написать объяснение только задачки `H`, так как она самая сложная.

- Есть специальный указатель `ptr`, изначально равный 0. Он будет отвечать за индекс, куда мы будем писать ненулевые элементы;
- Проходимся по всему массиву (индекс `i`) и записываем все ненулевые элементы, сохраняя порядок, в начало, с помощью индекса `ptr`: записываем в `lst[ptr]` значение `lst[i]`, не забывая прибавлять `ptr` при записи. Здесь важно понимать такой инвариант: `ptr <= i` всегда. Т.е. не будет такого, что мы перезапишем то, что еще не посмотрели.
- Таким образом под конец `ptr` у нас будет значить количество ненулевых элемент, либо же индекс, с которого должны идти нулевые элементы.
- Записываем начиная с этого `ptr` все нули.
- Выводим массив.

Решение работает за линию, так как мы один раз проходимся по всему этому массиву - `O(n)`, и дальше проходимся от меньше чем длину массиву, что тоже значит `O(n)`. `O(n) + O(n) = O(n)`. Из дополнительной памяти у нас только `ptr`, а это `O(1)` доп. памяти, а значит решение без дополнительной памяти.
